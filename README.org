#+title: Bash programming exercises
#+PROPERTY: header-args :tangle exercise1.sh
#+description:Bash programming exercises from: \
The Complete Guide to Bash Programming,educative.io\\
https://www.educative.io/courses/guide-to-bash-programming

* Contenido :TOC:
- [[#exercises][Exercises]]
  - [[#integrating-backup-script-to-bash][Integrating backup script to bash]]
  - [[#operator-][Operator [[]]
  - [[#operator--and-directories][Operator [[ and Directories]]
  - [[#case-stament-compressing-file][Case stament: compressing file]]
  - [[#case-estatement-rewrite-if-else-to-case][Case estatement, rewrite if else to case]]
  - [[#asociative-array][Asociative array]]
  - [[#loop-operators][Loop operators]]
    - [[#while][while]]
    - [[#until][until]]
    - [[#example][Example]]
    - [[#infinite-loop][Infinite loop]]
    - [[#reading-a-standard-input-stream][Reading a Standard Input Stream]]
    - [[#for-statement][/For/ Statement]]
      - [[#examples][Examples]]

* Exercises
** Integrating backup script to bash
1. Add the script’s path to the PATH variable. Edit the *~/.bash_profile* file for that.
2. Define the alias with an absolute path to the script. Do that in the *~/.bashrc file*.
3. Copy the script to the ~/usr/local/bin~ directory and make it executable:
#+begin_src shell
sudo cp -r make-backup.sh /usr/local/bin/ sudo chmod +x
/usr/local/bin/make-backup.sh
#+end_src
The PATH variable contains this path by default. If there is no such directory
in your environment, create it. \\
If we need to remove a declared alias, we call
the ~unalias~ Bash built-in. For example, this call removes the ~make-backup.sh~
alias:
#+begin_src shell
unalias make-backup.sh
#+end_src
Let’s suppose that we integrated the backup script with Bash in one of three
ways. Then, we can launch it by name, like this:
#+begin_src shell 
make-backup.sh photo
#+end_src
This is the final script:
#+begin_src shell :tangle ./exercises/make-backup.sh
#!/bin/bash

tar -cjf "$1".tar.bz2 "$1" && echo "tar - OK" > results.txt || { echo "tar - FAILS" > results.txt ; exit 1 ; }

mv -f "$1".tar.bz2 ~/backup && echo "cp - OK" >> results.txt || ! echo "cp - FAILS" >> results.txt
#+end_src
** Operator [[
 Write the Bash script with the following if condition:
    1. If the input parameter has a value of Alice, you print “Hello Alice”.
    2. If the input parameter has a value of Bob, you print “Hello Bob”.
    3. If none of the above cases hold, print “Hello John Doe”.
#+begin_src shell :tangle ./exercises/exercise0.sh
#!/bin/bash
if [[ "$1" = "Alice" ]]
then
    echo "Hello Alice"
elif [[ "$1" = "Bob" ]]
then
    echo "Hello Bob"
else
    echo "Hello Jhon Doe"
    exit 1;
fi
#+end_src  
** Operator [[ and Directories

Write a script to compare two directories named dir1 and dir2. The script should print all files from one directory that are absent in the other one.

#+begin_src shell  :tangle ./exercises/exercise1.sh

  #!/bin/bash
  cd dir1
  find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;

  cd ../dir2
  find . -type f -exec test ! -e ../dir1/{} \; -a -exec echo {} \;
  #+end_src 

** Case stament: compressing file
#+begin_src shell 
  !#/bin/bash
  operation="$1"

if [[ "$operation" == "-a" ]]
then
    tar -c -f documents.tar ~/Documents
elif [[ "$operation" == "-c" ]]
then
    tar -c -j -f documents.tar.bz2 ~/Documents
elif [[ "$operation" == "-x" ]]
then
    tar -x -f documents.tar*
else
    echo "Invalid option"
    exit 1
fi
#+end_src 

#+begin_src shell :tangle ./exercises/archiving-case.sh
  #!/bin/bash
  operation="$1"
  case "$operation" in
      "-a")
          tar -c -f documents.tar ~/Documents
      ;;

      "-c")
          tar -c -j -f documents.tar.bz2 ~/Documents
      ;;

      "-x")
          tar -x -f documents.tar*
      ;;

      ,*)
          echo "Invalid option"
          exit 1
      ;;
  esac
#+end_src
** Case estatement, rewrite if else to case
Consider the following script. Rewrite it with the case statement.

#+begin_src shell
#!/bin/bash
if [[ "$1" = "Alice" ]]
then
    echo "Hello Alice"
elif [[ "$1" = "Bob" ]]
then
    echo "Hello Bob"
else 
    echo "Hello John Doe"
fi
#+end_src

#+begin_src shell :tangle ./exercises/script.sh
#!/usr/bin/env bash
variable="$1"
case "$variable" in
    "Alice")
        echo "Hello Alice"
    ;;

    "Bob")
        echo "Hello Bob"
    ;;

    *)
        echo "Hello John Doe"
        exit 1;
    ;;
esac
#+end_src
** Asociative array
#+begin_src shell :tangle ./exercises/switch-config-case.sh
  #! /bin/bash

  opcion="$1"
  rm -r ~/.bashrc
  case "$opcion" in
      "h")
          ln -s ~/.bashrc-home ~/.bashrc
          ;;
      "w")
          ln -s ~/.bashrc-work ~/.bashrc
          ;;
      ,*)
          echo "opcion inválida"
          exit 1;
          ;;
  esac
#+end_src

#+begin_src shell :tangle ./exercises/switch-config-array.sh
  #!/bin/bash

  file="$1"

  rm ~/.bashrc

  case "$file" in
      "h")
          ln -s ~/.bashrc-home ~/.bashrc
          ;;

      "w")
          ln -s ~/.bashrc-work ~/.bashrc
          ;;

      ,*)
          echo "Invalid option"
          ;;
  esac
#+end_src
** Loop operators
*** while
#+begin_src shell
#!/bin/bash

while ! ping -c 1 -W 1 google.com &> /dev/null
do
  sleep 1
done
#+end_src
*** until
#+begin_src shell
#!/bin/bash

until ping -c 1 -W 1 google.com &> /dev/null
do
    sleep 1
done

echo "The google.com server is available"
#+end_src
*** Example
Sleep and create a file.
#+begin_src shell :tangle  ./exercises/sleep-and-create-a-file.sh
#sleep-and-create-a-file.sh
  sleep 5
  touch file.txt
#+end_src
#+begin_src shell :tangle ./exercises/check-a-file.sh
#!/bin/bash

# running the file in background 
./sleep-and-create-a-file.sh &

# using while loop to find the file
while [[ ! -e "./file.txt" ]]
do
  echo "File not found";
  sleep 1;
done

echo "File found!!!"
#+end_src

#+RESULTS:
: File found!!!

*** Infinite loop
En este script se muestra el espacio usado en el disco duro.
#+begin_src shell
#!/bin/bash

while true
do
	clear
	df -hT
	echo “Zzzzz”
	sleep 2
done
#+end_src
*** Reading a Standard Input Stream
Este texto pertenece al /contacts.txt/
#+begin_src shell
Alice=alice@gmail.com
Bob=(697) 955-5984
Eve=(245) 317-0117
Mallory=mallory@hotmail.com
#+end_src


#+begin_src shell :tangle ./exercises/while-contacts.sh
  #!/bin/bash

  declare -A array

  while IFS=$'=' read -r name contact
  do
      array[$name]=$contact
  done < "contacts.txt"

  echo "${array["$1"]}"
#./while-contacts.sh "Alice"

#+end_src
*** /For/ Statement
Here, we should not enclose the position parameter ~$1~ in quotes. Quotes prevent
word splitting. Without word splitting, Bash passes the whole string to the
first iteration of the ~for~ loop. Then, the loop finishes. We do not want this
behavior. The script should process each word of the string separately.
#+begin_src shell
#!/bin/bash

for word in $1
do
    echo "$word"
done
#+end_src
When we call the script, we should enclose the input string in the
double-quotes. Then, the whole string comes into the ~$1~ parameter. Here is an
example of calling the script: ~./for-string.sh "this is a string"~

There is a way to get rid of the double quotes when calling the script. Replace
the ~$1~ parameter in the for condition with ~$@~. Then, the loop statement becomes
like this:
#+begin_src shell
  #!/bin/bash
  for word in $@
  do
    echo "$word"
  done
#+end_src
Now, both following script calls work properly:
#+begin_src shell
./for-string.sh this is a string
./for-string.sh "this is a string"
#+end_src
The ~for~ has a short form.We use it when we need to handle all input parameters
of the script. This short-form looks like this:
#+begin_src shell
#get rid of "in $@"
  for word
  do
    echo "$word"
  done
#+end_src
**** Examples
For String
#+begin_src shell
#!/bin/bash
#"hola perro"
for word in $1
do
    echo "$word"
done
#+end_src
for path
#+begin_src shell
  #!/bin/bash
#hola,perro,asqueroso
#./for-path.sh "~/My Documents/file1.pdf,~/My Documents/report2.txt"
  IFS=$','
  for path in $1
  do
      echo "$path"
  done
#+end_src
for array
#+begin_src shell
#!/bin/bash
array=(Alice Bob Eve Mallory)

for element in "${array[@]}"
do
    echo "$element"
done
#+end_src
There is another way to handle the array.
1. Write the string with indices of the elements you need. They should be separated by spaces.
2. Put the string into the for condition.
3. The loop gives you an index on each iteration.
#+begin_src shell
array=(Alice Bob Eve Mallory)

for i in 0 1 2
do
  echo "${array[i]}"
done
#+end_src
or
#+begin_src shell
array=(Alice Bob Eve Mallory)

for i in {0..2}
do
  echo "${array[i]}"
done
#+end_src
for elements
#+begin_src shell
    #!/bin/bash

    array=(Alice Bob Eve Mallory)

    for element in "${array[@]:0:2}"
    do
        echo "$element"
    done
#Alice
#Bob
#+end_src
